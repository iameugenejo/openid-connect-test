{
  "name": "modelling",
  "version": "0.0.2",
  "description": "Simple model part for custom mvc over express/connect routes.",
  "keywords": [
    "Model",
    "MVC",
    "Flexible",
    "Waterline",
    "data-model",
    "middleware",
    "connect",
    "express",
    "db"
  ],
  "homepage": "https://github.com/agmoyano/modelling",
  "repository": {
    "type": "git",
    "url": "https://github.com/agmoyano/modelling.git"
  },
  "author": {
    "name": "Agust√≠n Moyano"
  },
  "dependencies": {
    "waterline": "git://github.com/balderdashy/waterline",
    "lodash": "*",
    "express": "*",
    "extend": "*"
  },
  "main": "index.js",
  "readme": "# Modelling\n\nSimple model part for custom mvc over express/connect routes. \n\nThe idea is quite simple. \n\nThis is the model part, your express route functions are the controllers, and your html is the view part.\n\nIt's just a wrapper over [Waterline](https://www.npmjs.org/package/waterline), to make it really easy to use with your express route middleware.\n\nWhy do this when you have great mvc frameworks like [Sails](https://www.npmjs.org/package/sails)?\n\nThe answer is simple, sometimes you don't need a framework. For example, if you are not creating an app, but a library, where you need to control part of the model, but you don't really know the whole model, a framework can be very annoying.\n\n## Install\n\nInstall via npm:\n\n    npm install modelling\n    \nTo use it inside your project:\n\n```\nvar orm = new modelling(options);\n``` \n\nand then, for example, with express:\n\n```\napp.get('/route/:id', orm.use('mymodel'), function(req, res, next) {\n\t//all waterline collections are placed in req.model\n\treq.model.mymodel.findOne({id: req.params.id}).exec(...);  \n});\n```\n\n## Options\n\n* __collections__\n\n  synonym for _\"models\"_.\n  \n* __adapters__\n\n  Waterline adapters definition. For example:\n  \n  ``` \n  var options = {\n  \tadapters: {\n  \t\tdisk: require('sails-disk')\n  \t}\n  };\n  \n  new modelling(options);\n  ```\n  \n* __connections__\n\n  Waterline adapters definition. For example:\n  \n  ```\n  var options = {\n\tconnections: {\n\t\tconn1: {\n\t\t\tadapter: 'disk'\n\t\t}\n\t}\n  };\n  new modelling(options);\n  ```\n  \n* __policies__\n\n  Policies to be applied to models. You write them in the form of express/connect middleware. They can be applied before or after retrieving the model. \n  \n  For example:\n  \n  ```\n  var options = {\n\tpolicies: {\n\t\tloggedIn: function(req, res, next) {\n\t\t\tif(req.session.userId) {\n\t\t\t\tnext();\n\t\t\t} else {\n\t\t\t\tres.redirect('/login');\n\t\t\t}\n\t\t},\n\t\tisAdmin: {\n\t\t\tfn: function(req, res, next) {\n\t\t\t\t(!req.model || !req.model.user) && return next('user model needed');\n\t\t\t\treq.model.user.findOne({id: req.session.userId}, function(err, user) {\n\t\t\t\t\tif(!err && user && user.isAdmin) {\n\t\t\t\t\t\tnext();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnext(err||'You are not Admin');\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t},\n\t\t\tafter: true\n\t\t}\n\t}\n  };\n  new modelling(options);\n  ```\n  Notice in this example that we have 2 policies defined, _\"loggedIn\"_ to ensure user is logged in, and _\"isAdmin\"_ to check if user has admin rights.\n  Because we need user data to check admin rights, we set _\"after\"_ property to true;\n  \n* __models__\n\n  Waterline models definition, but with an __optional__ extra parameter. The extra parameter is _\"policies\"_, and is a string, or array of strings where you define the name of default policies to apply to model.\n  \n  Models __must__ comply with waterline model definition. For example:\n  \n  ```\n  var options = {\n  \tmodels: {\n  \t\tuser: {\n  \t\t\tidentity: 'user',\n  \t\t\tconnection: 'conn1',\n  \t\t\tschema: true,\n  \t\t\tpolicies: 'loggedIn',\n  \t\t\tattributes: {\n  \t\t\t\tname: {type: 'string', required: true},\n  \t\t\t\tpass: {type: 'string', required: true},\n  \t\t\t\tisAdmin: 'boolean'\n  \t\t\t}\n  \t\t}\n  \t}\n  };\n  ```\n  \n##API\n\n###Adapters\n\n* **setAdapter([add,] [name,] adapter)**\n\n  Returns modelling instance for chaining purposes.\n  \n  * __add__ Boolean. If _true_, the adapter definition will be added to the rest. Otherwise adapters definition will be replaced. Defaults _false_.\n  * __name__ String. The name of the adapter definition. If ommited, _adapter_ definition must include the name as first property.\n  * __adapter__ Object. The definition of the adapter. If _name_ parameter was ommited _adapter_ definition must include the name as first property.\n  \n  The following are equivalent:\n    \n  ```\n  instance.setAdapter('pg', require('sails-postgres'));\n  ```\n    \n  ```\n  instance.setAdapter({pg: require('sails-postgres'});\n  ```\n  \n  If the adapter definition was already present, it will be overwritten.\n  \n  After all changes are made to adapters, _done_ function must be called to be applied in waterline.\n  \n* **adapters([name])**\n\n  Returns adapters definition. If _name_ is present, will return the definition of the specified adapter.\n  \n* **remAdapter([name])**\n\n  Returns modelling instance for chaining purposes.\n  \n  Deletes all adapters definition. If name is present, will only delete the definition for the specified adapter.\n  \n  After all changes are made to adapters, _done_ function must be called to be applied in waterline.\n  \n###Connections\n\n* **setConnection([add,] [name,] connection)**\n\n  Returns modelling instance for chaining purposes.\n  \n  * __add__ Boolean. If _true_, the connection definition will be added to the rest. Otherwise connections definition will be replaced. Defaults _false_.\n  * __name__ String. The name of the connection definition. If ommited, _connection_ definition must include the name as first property.\n  * __connection__ Object. The definition of the connection. If _name_ parameter was ommited _connection_ definition must include the name as first property.\n  \n  The following are equivalent:\n    \n  ```\n  instance.setConnection('localhost', {adapter: 'disk'});\n  ```\n    \n  ```\n  instance.setConnection({localhost: {adapter: 'disk'}});\n  ```\n  \n  If the connection definition was already present, it will be overwritten.\n  \n  After all changes are made to connections, _done_ function must be called to be applied in waterline.\n  \n* **connections([name])**\n\n  Returns connections definition. If _name_ is present, will return the definition of the specified connection.\n  \n* **remConnection([name])**\n\n  Returns modelling instance for chaining purposes.\n  \n  Deletes all connections definition. If name is present, will only delete the definition for the specified connection.\n  \n  After all changes are made to connections, _done_ function must be called to be applied in waterline.\n  \n###Models\n\n* **setModel([add,] [name,] model)**\n\n  Returns modelling instance for chaining purposes.\n  \n  * __add__ Boolean. If _true_, the model definition will be added to the rest. Otherwise models definition will be replaced. Defaults _false_.\n  * __name__ String. The name of the model definition. If ommited, _model_ definition must include the name as first property.\n  * __model__ Object. The definition of the model. If _name_ parameter was ommited _model_ definition must include the name as first property.\n  \n  The following are equivalent:\n    \n  ```\n  instance.setModel('localhost', {adapter: 'disk'});\n  ```\n    \n  ```\n  instance.setModel({localhost: {adapter: 'disk'}});\n  ```\n  \n  If the model definition was already present, it will be overwritten.\n  \n  After all changes are made to models, _done_ function must be called to be applied in waterline.\n  \n* **models([name])**\n\n  Returns models definition. If _name_ is present, will return the definition of the specified model.\n  \n* **remModel([name])**\n\n  Returns modelling instance for chaining purposes.\n  \n  Deletes all models definition. If name is present, will only delete the definition for the specified model.\n  \n  After all changes are made to models, _done_ function must be called to be applied in waterline.\n  \n###Policies\n\n* **setPolicy([add,] [name,] policy)**\n\n  Returns modelling instance for chaining purposes.\n  \n  * __add__ Boolean. If _true_, the policy definition will be added to the rest. Otherwise policies definition will be replaced. Defaults _false_.\n  * __name__ String. The name of the policy definition. If ommited, _policy_ definition must include the name as first property.\n  * __policy__ Object. The definition of the policy. If _name_ parameter was ommited _policy_ definition must include the name as first property.\n  \n  The following are equivalent:\n    \n  ```\n  instance.setPolicy('pg', require('sails-postgres'));\n  ```\n    \n  ```\n  instance.setPolicy({pg: require('sails-postgres'});\n  ```\n  \n  If the policy definition was already present, it will be overwritten.\n  \n  As policies are not a part of waterline, is not necesary to call _done_ function when you only change policies.\n  \n* **policies([name])**\n\n  Returns policies definition. If _name_ is present, will return the definition of the specified policy.\n  \n* **remPolicy([name])**\n\n  Returns modelling instance for chaining purposes.\n  \n  Deletes all policies definition. If name is present, will only delete the definition for the specified policy.\n  \n  As policies are not a part of waterline, is not necesary to call _done_ function when you only change policies.\n  \n###General\n\n* **done()**\n\n  Returns void. \n  \n  This function is called when you want to apply changes in models, adapters or connections.\n  \n* **use(options)**\n\n  Returns a function that can be placed as express/connect middleware. If all policies comply, it places all models specified in `req.model`.\n\t\n  __options__ can be a _string_, an _array_ of strings or an _object_.\n\t\n  * If it's a __string__ it will be interpreted as the name of the model you want to access. Default policies of the model will be applied.\n  * If it's an __array__ it will be interpreted as an array of names of the models you want to access. Default policies of all models will be applied.\n  * If it's an __object__, it must contain a _models_ property, and optionally can contain a _policies_ property.\n  \t* _models_: Has to be of type _string_ or _array_ of strings.\n  \t* _policies_: Here you can define custom policies to implement in a particular route. You can also override default policies of models. If you redefine a policy to `false`, it will not be applied this time.\n  \t\n  For example:\n  \n  ```\n  app.get('/user/docs', orm.use('user'), function(req, res, next) {\n  \t//\"user\" waterline's model definition is placed in req.model.user\n  \treq.model.user.findOne({id: req.session.userId}).populate('docs').exec(...);\n  });\n  ```\n  \n  Get the _user_ model in this route. Notice you can _populate_ other models; \n  \n  ```\n  app.post('/user/docs', orm.use(['user', 'docs']), function(req, res, next) {\n  \treq.model.user.findOne({id: req.session.userId}, function(err, user){\n  \t\tif(!err && user) {\n  \t\t\treq.model.docs.find().exec(function(err, docs){\n  \t\t\t\t//do something\n  \t\t\t});\n  \t\t}\n  \t});\n  });\n  ```\n  \n  This is an inefficient clone of the example above, but good for showing how to get both _user_ and _docs_ models in this route.\n  \n  Now, for the next example, we get a little more complicated. \n  \n  Suppose we are making _\"The John's Club\"_ application, and there is a form where users register themselves. \n  \n  Suppose there are two basic rules:\n  \n  * Your name must be 'John'.\n  * There cannot be two Johns with the same lastname.\n  \n  Here is what we could do:\n  \n  ```\n  app.post('/johns', orm.use({\n  \tpolicies: {\n  \t\tloggedIn: false,\n  \t\thasJohnName: function(req, res, next) {\n  \t\t\t//ensure username is John\n  \t\t\tif(req.body.name == 'John') {\n  \t\t\t\tnext();\n  \t\t\t} else {\n  \t\t\t\tnext(\"You'r not a John\");\n  \t\t\t}\n  \t\t},\n  \t\tuniqueLastname: {\n  \t\t\tfn: function(req, res, next) {\n  \t\t\t\treq.model.user.findOne({lastname: req.body.lastname}, function(err, user) {\n  \t\t\t\t\tif(err) return next(err);\n  \t\t\t\t\tif(user) return next('There is an other John with your lastname');\n  \t\t\t\t\tnext();\n  \t\t\t\t}\n  \t\t\t},\n  \t\t\tafter: true\n  \t\t}\n  \t},\n  \tmodels: 'user'\n  }), function(req, res, next) {\n  \t//create john user\n  });\n  ```\n  \n  As you see, we've got 3 policies. \n  * The first one actually overrides the loggedIn policy of user model. As this is the result of a post from an auto register form, we know the user won't be logged in. So we take this policy out. \n  * The second policy applies before we retrieve the model. It ensures that the name of the user is actually 'John'.\n  * The third rule applies after we retrieve the model. It ensures there is no other John with your lastname.\n\n<!--\n##What's next\n\n* Pub/Sub using socket.io for automatic data update in view (probably using Angular).\n* Automatic REST api for each model (still not sure about this).\n-->\n\n## Help!\n\nAny suggestions, bug reports, bug fixes, Pull Requests, etc, are very wellcome ([here](https://github.com/agmoyano/modelling/issues)). \n\nThanks for reading!.\n  \n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/agmoyano/modelling/issues"
  },
  "_id": "modelling@0.0.2",
  "_shasum": "b90d7b09242e42e8d6b2adcb51fbf619882d4d65",
  "_from": "modelling@*",
  "_resolved": "https://registry.npmjs.org/modelling/-/modelling-0.0.2.tgz"
}
